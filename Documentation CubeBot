int main() 
{

// This file includes Norman Advanced Robotic's Arm and Drive Functions

void arm_reset(int time)
{
    motor(0, -20);
    msleep(time); 
}

    
void go_to(int port, int position, int speed)
{
clear_motor_position_counter(port);

void move_motor()
{
    while(get_motor_position_counter(port) < position)
    {
      motor(port, speed);
    }    
    while(get_motor_position_counter(port) > position)
     {          
       motor(port, -speed);
     }
}
    move_motor();

}
   void claw_slow(int portC,int posC, int speedC) //port, position (0 - 2047), speed ( 0 - 30) is best 
    {
        enable_servos();
        int curr_pos = get_servo_position(portC); 

        if(curr_pos < posC)  //if position is less than - moves arm/claw up
        {
            while(curr_pos < posC) 
            {
                set_servo_position(portC, curr_pos); 
                msleep(30);

                curr_pos = curr_pos + speedC; //adds desired speed to the current position            
            }
        }

        if(curr_pos > posC)
        {
            while(curr_pos > posC)//if position is greater than - moves arm/claw down
            {
                set_servo_position(portC, curr_pos);
                msleep(30);

                curr_pos = curr_pos - speedC; //subtracts desired speed to the current position             
            }
        }
    }
    //go_to(0, 800, 10);

 void set_motor_position_and_move_claw(int portC,int posC, int speedC)
 {
     void claw_slow() //port, position (0 - 2047), speed ( 0 - 30) is best 
    {
        enable_servos();
        int curr_pos = get_servo_position(portC); 

        if(curr_pos < posC)  //if position is less than - moves arm/claw up
        {
            while(curr_pos < posC) 
            {
                set_servo_position(portC, curr_pos); 
                msleep(30);

                curr_pos = curr_pos + speedC; //adds desired speed to the current position            
            }
        }

        if(curr_pos > posC)
        {
            while(curr_pos > posC)//if position is greater than - moves arm/claw down
            {
                set_servo_position(portC, curr_pos);
                msleep(30);

                curr_pos = curr_pos - speedC; //subtracts desired speed to the current position             
            }
        }
    }
void motor_resist() 
{
    double time = .0001;
    motor(0, time);
    msleep(3000);
} 
     
thread motor_resistT = thread_create(motor_resist);
thread claw_slowT = thread_create(claw_slow);

     thread_start(motor_resistT); 
     thread_start(claw_slowT); 

     thread_wait(motor_resistT);
     thread_wait(claw_slowT);
     thread_destroy(motor_resistT);
     thread_destroy(claw_slowT);
 }
    void create_spin(int velocity)
{
	create_drive_direct(velocity, -1*velocity);
}


//positive angle spins the create clockwise
void create_spin_angle(int speed, int angle)
{
	set_create_total_angle(0);
	if(angle > 0)
	{
		create_spin(speed);
	}
	if(angle < 0)
	{
		create_spin(-1*speed);
	}
	int beginTime = systime();
	while(abs(get_create_total_angle()) < abs(angle)) msleep(1);
	int totTime = systime() - beginTime;
	
	printf("\nms per current angle: %d", totTime);
	printf("\ncurrent angle: %d", get_create_total_angle());
	create_stop();
}

//waits for the create button sensor to be touched
void create_wait_for_bump(int velocity)
{
	while(get_create_lbump(0)!=1 || get_create_rbump(0)!=1)
	{
		if(get_create_lbump(0)==0 && get_create_rbump(0)==1)
		{
			create_drive(velocity,0);
			msleep(100);
		}
		else if(get_create_lbump(0)==1 && get_create_rbump(0)==0)
		{
			create_drive(0,velocity);
			msleep(100);
		}
		else if(get_create_lbump(0)!=1&& get_create_rbump(0)!=1)
		{
			create_drive_straight(velocity);
			msleep(100);
		}
	}
}

void drive_until_range(int velocity, int target_range)
{
    while(analog(5) < target_range)
    {
        create_drive_segment(150, 100);
        msleep(100);
    }
}

// Shortened version of create_spin_angle
void spin(int v, int theta)
{
    create_spin_angle(v, theta);
    msleep(500);
}

// Shorted version of create_drive_segment
void drive(int vel, int dist) // in mm
{
    create_drive_segment(vel, dist);
    msleep(500);
} 

/*void set_up_arm_and_drive()
{
   
   thread driveT = thread_create(get_to_tower);
   thread set_posT = thread_create(set_pos);

     thread_start(driveT); 
     thread_start(set_posT); 

     thread_wait(driveT);
     thread_wait(set_posT);
     thread_destroy(driveT);
     thread_destroy(set_posT);
   
   }*/
   
   
        go_to(0, 740, 20);
        set_motor_position_and_move_claw(1, 0,20); 

        set_motor_position_and_move_claw(0, 0 ,35);   
        set_motor_position_and_move_claw(1, 1600,20); 

        go_to(0, -470, 20);
        set_motor_position_and_move_claw(0, 2047,35);   
		set_motor_position_and_move_claw(1,600,20); 
        go_to(0, 200, 20);


    return 0;
}


