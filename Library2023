/*
    jerk=1;
    int check=1;
    while(check==1)
    {
        //p1
        time=0.3*accelerationTime;
        acceleration=acceleration+jerk*time;
        velocity=velocity+acceleration*time+0.5*jerk*(time*time);
        
        //p2
        time=0.7*accelerationTime;
        velocity=velocity+acceleration*time;
        
        //p3
        time=accelerationTime;
        acceleration=acceleration+jerk*time;
        velocity=velocity+acceleration*time+0.5*jerk*(time*time);
        
        if(velocity>=velocity-50&&velocity<=velocity+50)
        {
            check=0;
        }
        else
        {
            if(velocity>speed)
            {
                jerk=jerk-jerk*0.5;
            }
            else
            {
                jerk=jerk+jerk*0.5;
            }
        }
        acceleration=0;
        velocity=0;
    }
*/
#define _USE_MATH_DEFINES
#include <math.h>
/*
CONTENTS (descending order):
Null variables *
Resources 0
List of all methods 1
Setup 2
Calibration methods 3
Drive methods 4
Turn methods 5
Line follow methods 6
Line square up methods 7

*/
NULL VARIABLES********************************************************************************************************************************************************
double rightWheelTicksPerCm;
double leftWheelTicksPerCm;
double ticksPerBotRotation;

/*RESOURCES**********************************************************************************************************************************************************0
    ACCELERATION PROFILES:
    https://www.pmdcorp.com/resources/type/articles/get/mathematics-of-motion-control-profiles-article
    
    TICKS CALIBRATION TOOL:
    https://docs.google.com/document/d/16l_TON05nS6aB2AMCCufq_iQrS7w6adQjx76DrSltB0/edit?usp=sharing
*/

/*METHODS LIST*******************************************************************************************************************************************************1
CALIBRATION:
    calibrateMotorTicks(port);
        Using the button on the wallaby, manually drive a wheel a full revolution. Returns the tick count
        of the motor after 5 seconds of not pressing the button.
        
    calibrateMotorTicksAdvanced(port);
        Same as calibrateMotorTicks but lets you set the position of the wheel before the rotation that finds ticks.
        If you're not marking the wheel, use this and line one of the spokes of the wheel up with something so that
        after a full rotation they re-align.
        
    calibrateMotorTicksTool(port);
        Using a physical tool, returns how many ticks there are in a revolution of a motor by pressing
        a bump sensor after 360 degrees of a rotation
        
    calibrateMotorOffset();
        After ticks in a revolution have already been found, this method calibrates the offset between
        motor speeds (how far behind in speed one motor is compared to the other) by timing how long it
        takes for each motor to fully rotate (once the tick value is reached)
        
DRIVING:
    drive(distanceInCm(-/+),speed(1-1500));
        Uses s-curve acceleration to minimize slipping. Also factors in motor offset every time a new speed is
        set for motors in order to ensure straight driving. A ticks/cm (look at turn methods for explanation)
        variable is used to track how far the motors have turned so that accurate distances can be driven, and
        acceleration time is set to 0.5, meaning it takes 0.5 seconds to accelerate and 0.5 seconds to deccelerate.
        
    driveSimple(distanceInCm(-/+),speed(1-1500));
        Doesn't use any acceleration profiles. Instead just uses the motor offset and ticks/cm variable to
        drive straight for a certain distance.
        
    driveAdvanced(distanceInCm(-/+),speed(1-1500),accelerationTime);
        Same as the normal drive but you set the accelerationTime variable.
        
TURNING:
    turnRight(degrees,speed(1-1500));
    turnLeft(degrees,speed(1-1500));
        Like the drive function, turning uses s-curve acceleration to reduce slipping. Using the circumference
        of a circle created by the distance between motors, the correct distance for each wheel to cover can be
        found. Knowing the circumference of the wheels and how many ticks there are in a full revolution
        for a motor, a ticks/cm variable is created. This variable in conjunction with the known distance to cover
        for each wheel allows the motors to turn for a certain amount of ticks, turning the bot to the correct angle.
        
    turnRightSimple(degrees,speed(1-1500));
    turnLeftSimple(degrees,speed(1-1500));
        Doesn't use any acceleration profiles.
        
    turnRightAdvanced(degrees,speed(1-1500),accelerationCoefficient);
    turnLeftAdvanced(degrees,speed(1-1500),accelerationCoefficient);
        Same as the normal turn but you set the acceleration coefficient. A higher number will make the accel/deccel
        faster. A lower number will do the opposite.
        
LINE FOLLOWING:
    lineFollowRight(double distanceInCm,int speed,int port);
    lineFollowLeft(double distanceInCm,int speed,int port);
        Line follows on a specific side of the tape. lineFollowRight line follows when the line sensor is on the RIGHT
        side of the tape, lineFollowLeft line follows when the line sensor is on the LEFT side of the tape. Also, has a
        set correctionStrength value of 0.2, meaning that the slower motor will always be 0.2*velocity behind
        the other motor in order to correct. The accelerationTime value is set to 0.5, meaning that it takes 0.5 seconds
        for each motor to accelerate to full speed and 0.5 seconds to deccelerate to 0 speed.
    lineFollowRightAdvanced(double distanceInCm,int speed,int port,double correctionStrength,double accelerationTime);
    lineFollowLeftAdvanced(double distanceInCm,int speed,int port,double correctionStrength,double accelerationTime);
        Same as the normal line follow but allows you to set the correctionStrength and accelerationTime variables.
*/

//SETUP**************************************************************************************************************************************************************2
//STEP 1: set variables
int rightMotor = 0;
int leftMotor = 3;
int bumpSensor=0;
int lineSensor=0;
double wheelDiameterInCm=6.8;
double distanceBetweenWheelsInCm = 19.9;
int lineSensorThreshold=1500;
//^a value that is never reached when sensing on white and is always less than when on black

//Set these during step 2
int rightMotorTicksPerRevolution=1924;
int leftMotorTicksPerRevolution=1922;
double motorOffset=0.95;
int slowMotor=0;
//^used to tell which motor the motorOffset needs to be applied to (the faster one)

//STEP 2: calibrate each motor being used, then calibrate the motor offset****
/*
EITHER use calibrateMotorTicks(port); which doesn't require a tool or you to remove the motors 
but does involve human error (calibrateMotorTicksAdvanced(port); can be used too - look at METHODS
for the description of the difference)
OR build a motor calibration tool by following the instructions in this link:
https://docs.google.com/document/d/16l_TON05nS6aB2AMCCufq_iQrS7w6adQjx76DrSltB0/edit?usp=sharing
Once it's built, connect a motor to the tool and run the calibration method: calibrateMotorTicksTool(port);

Once both motors are calibrated, reconnect them to the bot and run the motor offset calibration:
calibrateMotorOffset();
This finds the difference in speeds between both motors in order to make both motors run at the same speed.
*/

//CALIBRATION METHODS************************************************************************************************************************************************3
void calibrateMotorTicksTool(int port)
{
    printf("Press button when ready.\n");
    while(any_button()==0);
    msleep(1000);
    cmpc(port);
    mav(port,500);
    while(bumpSensor==0);
    int motorTicksPerRevolution=gmpc(port);
    mav(port,0);
    if(port==rightMotor)
    {
        printf("Set the rightMotorTicksPerRevolution variable equal to %f.\n",motorTicksPerRevolution);
    }
    else
    {
        printf("Set the leftMotorTicksPerRevolution variable equal to %f.\n",motorTicksPerRevolution);
    }
}

void calibrateMotorTicks(int port)
{
    printf("Pick the bot up and either make a mark on the wheel or watch a certain point on the wheel.\n");
    printf("Use the button to make the wheel turn a full revolution until the point is back where it started.\n");
    printf("Pressing the button will make the wheel slowly rotate. You can stutter press it to make minor adjustments,\n");
    printf(" but after 5 seconds of not being pressed, the ticks/revolution value will be returned.\n");
    while(any_button()==0);
    cmpc(port);
    double timeDifference=seconds();
    double time=0;
    while(time<5)
    {
        while(any_button==1)
        {
            mav(port,100);
            timeDifference=seconds();
        }
        mav(port,0);
        time=seconds()-timeDifference;
    }
    int motorTicksPerRevolution=gmpc(port);
    if(port==rightMotor)
    {
        printf("Set the rightMotorTicksPerRevolution variable equal to %f.\n",motorTicksPerRevolution);
    }
    else
    {
        printf("Set the leftMotorTicksPerRevolution variable equal to %f.\n",motorTicksPerRevolution);
    }
}

void calibrateMotorTicksAdvanced(int port)
{
    printf("Pick the bot up and press the button to make the wheel turn to where you want it for the calibration.\n");
    printf("Pressing the button will make the wheel slowly rotate. You can stutter press it to make minor adjustments,\n");
    printf(" but after 5 seconds of not being pressed the calibration will start.\n");
    while(any_button()==0);
    double timeDifference=seconds();
    double time=0;
    while(time<5)
    {
        while(any_button==1)
        {
            mav(port,100);
            timeDifference=seconds();
        }
        mav(port,0);
        time=seconds()-timeDifference;
    }
    cmpc(port);
    printf("Now press the button to rotate the wheel one full rotation. Like before, after 5 seconds of not being pressed\n");
    printf(" the calibration will end and a value will be returned.\n");
    while(any_button()==0);
    timeDifference=seconds();
    time=0;
    while(time<5)
    {
        while(any_button==1)
        {
            mav(port,100);
            timeDifference=seconds();
        }
        mav(port,0);
        time=seconds()-timeDifference;
    }
    int motorTicksPerRevolution=gmpc(port);
    if(port==rightMotor)
    {
        printf("Set the rightMotorTicksPerRevolution variable equal to %f.\n",motorTicksPerRevolution);
    }
    else
    {
        printf("Set the leftMotorTicksPerRevolution variable equal to %f.\n",motorTicksPerRevolution);
    }
}

void calibrateMotorOffset()
{
    printf("Pick the bot up and press button when ready.\n");
    while(any_button()==0);
    msleep(1000);
    cmpc(rightMotor,leftMotor);
    double rightMotorTime=seconds();
    double leftMotorTime=seconds();
    int rightLoopBreak=0;
    int leftLoopBreak=0;
    mav(rightMotor,500);
    mav(leftMotor,500);
    while(rightLoopBreak==0||leftLoopBreak==0)
    {
        if(rightLoopBreak=0)
        {
            if(gmpc(rightMotor)>=rightMotorTicksPerRevolution)
            {
                rightMotorTime=seconds()-rightMotorTime;
                rightLoopBreak=1;
                mav(rightMotor,0);
            }
        }
        if(leftLoopBreak=0)
        {
            if(gmpc(leftMotor)>=leftMotorTicksPerRevolution)
            {
                leftMotorTime=seconds()-leftMotorTime;
                leftLoopBreak=1;
                mav(leftMotor,0);
            }
        }
    }
    if(rightMotorTime<=leftMotorTime)
    {
        motorOffset=rightMotorTime/leftMotorTime;
        printf("Set the motorOffset variable to %f and the slowMotor variable to 0.\n",motorOffset);
    }
    else
    {
        motorOffset=leftMotorTime/rightMotorTime;
        printf("Set the motorOffset variable to %f and the slowMotor variable to 1.\n",motorOffset);
    }
}

//DRIVE METHODS******************************************************************************************************************************************************4
void drive(double distanceInCm,int speed)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    //Setting equation variables
    double accelerationTime=0.5;
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    phase 2 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 3 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 6 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            if(distanceInCm<0)
            {
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
                while(gmpc(rightMotor)>rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)>leftWheelTicksPerCm*distanceInCm-leftAccelTicks);
            }
            else
            {
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
                while(gmpc(rightMotor)<rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)<leftWheelTicksPerCm*distanceInCm-leftAccelTicks);
            }
            phaseNumber=phaseNumber+1;
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void driveSimple(double distanceInCm,int speed)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    if(distanceInCm<0)
    {
        while(gmpc(rightMotor)>rightWheelTicksPerCm*distanceInCm||gmpc(leftMotor)>leftWheelTicksPerCm*distanceInCm)
        {
            mav(rightMotor,-1*speed*rightMotorOffset);
            mav(leftMotor,-1*speed*leftMotorOffset);
        }
    }
    else
    {
        while(gmpc(rightMotor)<rightWheelTicksPerCm*distanceInCm||gmpc(leftMotor)<leftWheelTicksPerCm*distanceInCm)
        {
            mav(rightMotor,speed*rightMotorOffset);
            mav(leftMotor,speed*leftMotorOffset);
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void driveAdvanced(double distanceInCm,int speed,double accelerationTime)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    //Setting equation variables
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    phase 2 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 3 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 6 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(distanceInCm<0)
                {
                    mav(rightMotor,-1*velocity*rightMotorOffset);
                    mav(leftMotor,-1*velocity*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            if(distanceInCm<0)
            {
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
                while(gmpc(rightMotor)>rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)>leftWheelTicksPerCm*distanceInCm-leftAccelTicks);
            }
            else
            {
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
                while(gmpc(rightMotor)<rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)<leftWheelTicksPerCm*distanceInCm-leftAccelTicks);
            }
            phaseNumber=phaseNumber+1;
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

//TURN METHODS*******************************************************************************************************************************************************5
void turnRight(double degrees,int speed)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    cmsForEachWheelToCover=0.5*(distanceBetweenWheelsInCm*M_PI)*(degrees/360);
    rightWheelDistance=cmsForEachWheelToCover*rightWheelTicksPerCm;
    leftWheelDistance=cmsForEachWheelToCover*lefttWheelTicksPerCm;
    //Setting equation variables
    double accelerationTime=0.5;
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    phase 2 of s-curve: V(t)=Vo+At
    phase 3 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 6 of s-curve: V(t)=Vo+At
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            mav(rightMotor,-1*velocity*rightMotorOffset);
            mav(leftMotor,velocity*leftMotorOffset);
            while(gmpc(rightMotor)>-1*rightWheelDistance-rightAccelTicks||gmpc(leftMotor)<leftWheelDistance-leftAccelTicks);
            phaseNumber=phaseNumber+1;
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void turnRightSimple(double degrees,int speed)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    cmsForEachWheelToCover=0.5*(distanceBetweenWheelsInCm*M_PI)*(degrees/360);
    rightWheelDistance=cmsForEachWheelToCover*rightWheelTicksPerCm;
    leftWheelDistance=cmsForEachWheelToCover*lefttWheelTicksPerCm;
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    while(gmpc(rightMotor)>-1*rightWheelDistance||gmpc(leftMotor)<leftWheelDistance)
    {
        mav(rightMotor,-1*speed*rightMotorOffset);
        mav(leftMotor,speed*leftMotorOffset);
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void turnRightAdvanced(double degrees,int speed,double accelerationTime)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    cmsForEachWheelToCover=0.5*(distanceBetweenWheelsInCm*M_PI)*(degrees/360);
    rightWheelDistance=cmsForEachWheelToCover*rightWheelTicksPerCm;
    leftWheelDistance=cmsForEachWheelToCover*lefttWheelTicksPerCm;
    //Setting equation variables
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    phase 2 of s-curve: V(t)=Vo+At
    phase 3 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 6 of s-curve: V(t)=Vo+At
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,-1*velocity*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            mav(rightMotor,-1*velocity*rightMotorOffset);
            mav(leftMotor,velocity*leftMotorOffset);
            while(gmpc(rightMotor)>-1*rightWheelDistance-rightAccelTicks||gmpc(leftMotor)<leftWheelDistance-leftAccelTicks);
            phaseNumber=phaseNumber+1;
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void turnLeft(double degrees,int speed)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    cmsForEachWheelToCover=0.5*(distanceBetweenWheelsInCm*M_PI)*(degrees/360);
    rightWheelDistance=cmsForEachWheelToCover*rightWheelTicksPerCm;
    leftWheelDistance=cmsForEachWheelToCover*lefttWheelTicksPerCm;
    //Setting equation variables
    double accelerationTime=0.5;
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    phase 2 of s-curve: V(t)=Vo+At
    phase 3 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 6 of s-curve: V(t)=Vo+At
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            mav(rightMotor,velocity*rightMotorOffset);
            mav(leftMotor,-1*velocity*leftMotorOffset);
            while(gmpc(rightMotor)<rightWheelDistance-rightAccelTicks||gmpc(leftMotor)>-1*leftWheelDistance-leftAccelTicks);
            phaseNumber=phaseNumber+1;
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void turnLeftSimple(double degrees,int speed)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    cmsForEachWheelToCover=0.5*(distanceBetweenWheelsInCm*M_PI)*(degrees/360);
    rightWheelDistance=cmsForEachWheelToCover*rightWheelTicksPerCm;
    leftWheelDistance=cmsForEachWheelToCover*lefttWheelTicksPerCm;
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    while(gmpc(rightMotor)<rightWheelDistance||gmpc(leftMotor)>-1*leftWheelDistance)
    {
        mav(rightMotor,speed*rightMotorOffset);
        mav(leftMotor,-1*speed*leftMotorOffset);
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void turnLeftAdvanced(double degrees,int speed,double accelerationTime)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    cmsForEachWheelToCover=0.5*(distanceBetweenWheelsInCm*M_PI)*(degrees/360);
    rightWheelDistance=cmsForEachWheelToCover*rightWheelTicksPerCm;
    leftWheelDistance=cmsForEachWheelToCover*lefttWheelTicksPerCm;
    //Setting equation variables
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    phase 2 of s-curve: V(t)=Vo+At
    phase 3 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo-(Aot+1/2Jt^2)
    phase 6 of s-curve: V(t)=Vo+At
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,-1*velocity*leftMotorOffset);
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            mav(rightMotor,velocity*rightMotorOffset);
            mav(leftMotor,-1*velocity*leftMotorOffset);
            while(gmpc(rightMotor)<rightWheelDistance-rightAccelTicks||gmpc(leftMotor)>-1*leftWheelDistance-leftAccelTicks);
            phaseNumber=phaseNumber+1;
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

//LINE FOLLOW METHODS************************************************************************************************************************************************6
void lineFollowRight(double distanceInCm,int speed,int port)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    //Setting equation variables
    double correctionStrength=0.2;
    double accelerationTime=0.5;
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    phase 2 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 3 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 6 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            if(analog(port)<lineSensorThreshold)
            {
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
            }
            else
            {
                mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            if(gmpc(rightMotor)=>rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)=>leftWheelTicksPerCm*distanceInCm-leftAccelTicks)
            {
                phaseNumber=phaseNumber+1;
            }
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void lineFollowRightAdvanced(double distanceInCm,int speed,int port,double correctionStrength,double accelerationTime)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    //Setting equation variables
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    phase 2 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 3 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 6 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)<lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            if(analog(port)<lineSensorThreshold)
            {
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
            }
            else
            {
                mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            if(gmpc(rightMotor)=>rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)=>leftWheelTicksPerCm*distanceInCm-leftAccelTicks)
            {
                phaseNumber=phaseNumber+1;
            }
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}
void lineFollowLeft(double distanceInCm,int speed,int port)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    //Setting equation variables
    double correctionStrength=0.2;
    double accelerationTime=0.5;
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    phase 2 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 3 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 6 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            if(analog(port)>lineSensorThreshold)
            {
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
            }
            else
            {
                mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            if(gmpc(rightMotor)=>rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)=>leftWheelTicksPerCm*distanceInCm-leftAccelTicks)
            {
                phaseNumber=phaseNumber+1;
            }
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

void lineFollowLeftAdvanced(double distanceInCm,int speed,int port,double correctionStrength,double accelerationTime)
{
    cmpc(rightMotor,leftMotor);
    //Giving null variables values
    rightWheelTicksPerCm=rightMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    leftWheelTicksPerCm=leftMotorTicksPerRevolution/(wheelDiameterInCm*M_PI);
    //Setting equation variables
    double velocity=0;
    double acceleration;
    //Finding accelerationConstant for phase 2
    double accelerationConstant=((speed*0.7)-(speed*0.3))/(accelerationTime*0.7);
    //Finding jerk using phase 3 (because Ao is already defined as accelerationConstant)
    double jerk=2*(speed-speed*0.7-accelerationConstant*accelerationTime)/(accelerationTime*accelerationTime);
    
    //determine which motor needs to be slowed down (the one with the offset)
    if(slowMotor==0)
    {
        rightMotorOffset=1;
        leftMotorOffset=motorOffset;
    }
    else
    {
        rightMotorOffset=motorOffset;
        leftMotorOffset=1;
    }
    
    /*
    phase 1 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    phase 2 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 3 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 4 of s-curve: V(t)=Vo
    phase 5 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao-Jt
    phase 6 of s-curve: V(t)=Vo+At, A(t)=Ao
    phase 7 of s-curve: V(t)=Vo+Aot+1/2Jt^2, A(t)=Ao+Jt
    */
    
    int phaseNumber=1;
    //^condition variable that determines which equation will be used
    double timeDifference;
    double time;
    while(phaseNumber<8)
    {
        timeDifference=seconds();
        if(phaseNumber==1||phaseNumber==7)
        {
            while(velocity<0.3*speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.001*speed&&phaseNumber==7)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration+jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==2||phaseNumber==6)
        {
            while(velocity<0.7*speed)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.3*speed&&phaseNumber==6)
            {
                time=seconds()-timeDifference;
                velocity=velocity+accelerationConstant*time;
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==3||phaseNumber==5)
        {
            while(velocity<speed)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            while(velocity>0.7*speed&&phaseNumber==5)
            {
                time=seconds()-timeDifference;
                acceleration=acceleration-jerk*time;
                velocity=velocity+acceleration*time+0.5*jerk*(time*time);
                if(analog(port)>lineSensorThreshold)
                {
                    mav(rightMotor,velocity*rightMotorOffset);
                    mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
                }
                else
                {
                    mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                    mav(leftMotor,velocity*leftMotorOffset);
                }
            }
            phaseNumber=phaseNumber+1;
        }
        else if(phaseNumber==4)
        {
            time=seconds()-timeDifference;
            int rightAccelTicks=gmpc(rightMotor);
            int leftAccelTicks=gmpc(leftMotor);
            //^The amount of ticks it took for each motor to accelerate to mav velocity (whatever speed is)
            //Theoretically, decelerating will take the same amount of ticks, so we want to preserve equal distance at the end for deceleration
            if(analog(port)>lineSensorThreshold)
            {
                mav(rightMotor,velocity*rightMotorOffset);
                mav(leftMotor,(velocity-correctionStrength*velocity)*leftMotorOffset);
            }
            else
            {
                mav(rightMotor,(velocity-correctionStrength*velocity)*rightMotorOffset);
                mav(leftMotor,velocity*leftMotorOffset);
            }
            if(gmpc(rightMotor)=>rightWheelTicksPerCm*distanceInCm-rightAccelTicks||gmpc(leftMotor)=>leftWheelTicksPerCm*distanceInCm-leftAccelTicks)
            {
                phaseNumber=phaseNumber+1;
            }
        }
    }
    mav(rightMotor,0);
    mav(leftMotor,0);
}

//LINE SQUARE UP METHODS*********************************************************************************************************************************************7
void lineSquareUp()
{
    
}

//
